<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Playing - Bead 16</title>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<style>
    body { background: #e0c097; margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: sans-serif; background-image: repeating-linear-gradient(45deg, rgba(139, 69, 19, 0.1) 0, rgba(139, 69, 19, 0.1) 2px, transparent 2px, transparent 6px); }
    #hud { position: absolute; top: 0; width: 100%; display: flex; justify-content: space-between; padding: 15px; box-sizing: border-box; font-weight: bold; background: rgba(0,0,0,0.5); color: #fff; z-index: 10; }
    #status { position: absolute; bottom: 20px; background: #333; color: #fff; padding: 10px 20px; border-radius: 20px; font-weight: bold; z-index: 10; }
    canvas { background: rgba(255,255,255,0.2); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
    #modal { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; flex-direction:column; justify-content:center; align-items:center; color:#fff; z-index:100; display:none; }
</style>
</head>
<body>

<div id="hud">
    <div style="color:#ff5252">ðŸ”´ OPP: <span id="s-opp">16</span></div>
    <div style="color:#448aff">ðŸ”µ YOU: <span id="s-you">16</span></div>
</div>
<div id="status">Waiting...</div>
<canvas id="canvas"></canvas>

<!-- Modal for waiting/result -->
<div id="modal">
    <h1 id="m-title">Searching...</h1>
    <p id="m-desc">Finding player...</p>
    <button onclick="location.href='home.html'" style="padding:10px 30px; margin-top:20px; background:#d4af37; border:none; border-radius:5px; font-weight:bold;">EXIT</button>
</div>

<script>
    // --- FIREBASE SETUP ---
    const firebaseConfig = { apiKey: "AIzaSyC2Uxgv0vjY2G6xgQ6jAwOkKHIp8wKRFvk", authDomain: "game-ee829.firebaseapp.com", databaseURL: "https://game-ee829-default-rtdb.firebaseio.com", projectId: "game-ee829", storageBucket: "game-ee829.firebasestorage.app", messagingSenderId: "70259643410", appId: "1:70259643410:web:2539716504e7ba635434cb" };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // --- PARAMS & STATE ---
    const urlParams = new URLSearchParams(window.location.search);
    const mode = urlParams.get('mode'); // 'online', 'offline', 'invite'
    const inviteCode = urlParams.get('code');
    const myPhone = localStorage.getItem('art_user_phone');
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let nodes = [], pieces = [], turn = 1, myTeam = 1; // 1=Blue(You), 0=Red(Opp)
    let selected = null, validMoves = [], gameId = null, isBot = false;
    let chainPiece = null;

    // --- INITIALIZATION ---
    function init() {
        resize();
        createBoard();
        
        if (mode === 'offline') {
            document.getElementById('status').innerText = "Vs Bot";
            isBot = true;
            startGame();
        } else if (mode === 'online') {
            findMatch();
        } else if (mode === 'invite') {
            joinPrivate(inviteCode);
        }
    }

    function resize() {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
        canvas.width = size;
        canvas.height = size * 1.2; 
    }

    // --- MATCHMAKING ---
    function findMatch() {
        document.getElementById('modal').style.display = 'flex';
        
        // Check Queue
        db.ref('queue').once('value', snap => {
            let found = false;
            snap.forEach(child => {
                if(!found && child.val().p1 !== myPhone) {
                    gameId = child.key;
                    db.ref('queue/'+gameId).remove();
                    db.ref('games/'+gameId).set({
                        p1: child.val().p1, p2: myPhone,
                        board: pieces, turn: 1, status: 'active'
                    });
                    myTeam = 0; // Joined as P2 (Red/Top)
                    found = true;
                }
            });

            if(!found) {
                gameId = db.ref('queue').push({ p1: myPhone, time: Date.now() }).key;
                myTeam = 1; // Created as P1 (Blue/Bottom)
                // Wait for opponent
                db.ref('games/'+gameId).on('value', gSnap => {
                    if(gSnap.exists()) {
                        document.getElementById('modal').style.display = 'none';
                        listenGame();
                    }
                });
                
                // Bot Fallback after 10s
                setTimeout(() => {
                    if(document.getElementById('modal').style.display === 'flex') {
                        db.ref('queue/'+gameId).remove();
                        db.ref('games/'+gameId).off();
                        mode = 'offline'; isBot = true;
                        document.getElementById('modal').style.display = 'none';
                        document.getElementById('status').innerText = "Playing vs Bot (No Opponent Found)";
                        startGame();
                    }
                }, 10000);
            } else {
                document.getElementById('modal').style.display = 'none';
                listenGame();
            }
        });
    }

    function joinPrivate(code) {
        gameId = code;
        document.getElementById('modal').style.display = 'flex';
        document.getElementById('m-title').innerText = "Waiting for Friend...";
        
        db.ref('games/'+gameId).once('value', s => {
            if(!s.exists()) {
                // Create
                db.ref('games/'+gameId).set({ p1: myPhone, board: pieces, turn: 1, status: 'waiting' });
                myTeam = 1;
                db.ref('games/'+gameId).on('value', gs => {
                    if(gs.val().status === 'active') {
                        document.getElementById('modal').style.display = 'none';
                        listenGame();
                    }
                });
            } else if(s.val().status === 'waiting') {
                // Join
                db.ref('games/'+gameId).update({ p2: myPhone, status: 'active' });
                myTeam = 0;
                document.getElementById('modal').style.display = 'none';
                listenGame();
            }
        });
    }

    // --- GAME LOOP ---
    function listenGame() {
        db.ref('games/'+gameId).on('value', snap => {
            const g = snap.val();
            if(!g) return;
            pieces = g.board || pieces;
            turn = g.turn;
            updateStatus();
            draw();
            checkWin(true); // Check win online
        });
    }

    function syncMove() {
        if(mode !== 'offline') {
            db.ref('games/'+gameId).update({ board: pieces, turn: turn });
        }
    }

    // --- BOARD LOGIC (Bead 16) ---
    function createBoard() {
        nodes = []; pieces = [];
        const w = canvas.width, h = canvas.height;
        const uX = w/8, uY = h/10, cx = w/2, cy = h/2;
        let id=0;

        for(let r=0; r<9; r++) {
            for(let c=0; c<5; c++) {
                let v = (r==0&&c==2) || (r==1&&c>=1&&c<=3) || (r>=2&&r<=6) || (r==7&&c>=1&&c<=3) || (r==8&&c==2);
                if(v) {
                    let px = cx + (c-2)*uX*1.3, py = cy + (r-4)*uY;
                    nodes.push({x:px, y:py, r, c, id:id++, n:[]});
                }
            }
        }
        
        // Neighbors
        nodes.forEach(n1 => {
            nodes.forEach(n2 => {
                if(n1===n2) return;
                let dr=Math.abs(n1.r-n2.r), dc=Math.abs(n1.c-n2.c);
                if((dr==1&&dc==0)||(dr==0&&dc==1)||(dr==1&&dc==1)) n1.n.push(n2.id);
            });
        });

        // Pieces (Red=0=Top, Blue=1=Bottom)
        nodes.forEach(n => {
            if(n.r<4) pieces.push({id:n.id, t:0, a:1});
            if(n.r>4) pieces.push({id:n.id, t:1, a:1});
        });
    }

    // --- GAMEPLAY INPUT ---
    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', e => { handleInput(e.touches[0]); e.preventDefault(); }, {passive:false});

    function handleInput(e) {
        if(turn !== myTeam && !isBot && mode !== 'offline') return; // Online turn check
        if(isBot && turn === 0) return; // Bot turn check
        
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;

        let clicked = nodes.find(n => (mx-n.x)**2 + (my-n.y)**2 < 900);
        if(!clicked) return;

        // Move Execution
        let move = validMoves.find(m => m.to === clicked.id);
        if(move) {
            executeMove(selected, move);
            return;
        }

        // Selection
        let p = pieces.find(p => p.id === clicked.id && p.a);
        if(p && p.t === (mode==='offline' ? turn : myTeam)) {
             if(chainPiece && p !== chainPiece) return; // Locked by chain
             selected = p;
             calcMoves(p);
             if(chainPiece) validMoves = validMoves.filter(m=>m.kill); // Only capture allowed
             draw();
        }
    }

    function calcMoves(p) {
        validMoves = [];
        let n = nodes[p.id];
        n.n.forEach(nid => {
            let occ = pieces.find(x => x.id === nid && x.a);
            if(!occ) { 
                if(!chainPiece) validMoves.push({to:nid}); 
            } else if(occ.t !== p.t) {
                // Jump logic
                let n2 = nodes[nid];
                let dr = n2.r - n.r, dc = n2.c - n.c;
                let n3 = nodes.find(x => x.r === n2.r+dr && x.c === n2.c+dc);
                if(n3 && !pieces.find(x => x.id === n3.id && x.a)) {
                    // Physical check simplified
                    if(n2.n.includes(n3.id)) validMoves.push({to:n3.id, kill:occ});
                }
            }
        });
    }

    function executeMove(p, m) {
        p.id = m.to;
        let captured = false;
        if(m.kill) {
            m.kill.a = 0;
            captured = true;
        }

        // Chain Logic
        selected = null; validMoves = [];
        if(captured) {
            calcMoves(p);
            if(validMoves.some(x => x.kill)) {
                chainPiece = p;
                selected = p;
                draw();
                if(mode !== 'offline') syncMove(); 
                if(isBot && turn === 0) setTimeout(botMove, 500);
                return; // Turn continues
            }
        }

        chainPiece = null;
        turn = 1 - turn;
        updateStatus();
        draw();
        
        if(mode !== 'offline') syncMove();
        else if(isBot && turn === 0) setTimeout(botMove, 500);

        checkWin(false);
    }

    // --- BOT ---
    function botMove() {
        let opts = [];
        pieces.filter(p=>p.t===0 && p.a).forEach(p => {
            calcMoves(p);
            validMoves.forEach(m => opts.push({p, m, s: m.kill?10:1}));
        });
        
        if(opts.length) {
            opts.sort((a,b)=>b.s-a.s);
            let pick = opts[0]; // Simple best move
            selected = pick.p;
            executeMove(pick.p, pick.m);
        } else {
            turn = 1; // Pass
        }
    }

    function updateStatus() {
        let r = pieces.filter(p=>p.t===0&&p.a).length;
        let b = pieces.filter(p=>p.t===1&&p.a).length;
        document.getElementById('s-opp').innerText = r;
        document.getElementById('s-you').innerText = b;
        document.getElementById('status').innerText = (turn === myTeam) ? "YOUR TURN" : "OPPONENT TURN";
    }

    function checkWin(isOnlineSync) {
        let r = pieces.filter(p=>p.t===0&&p.a).length;
        let b = pieces.filter(p=>p.t===1&&p.a).length;
        if(r===0 || b===0) {
            let win = (b>0 && myTeam===1) || (r>0 && myTeam===0);
            alert(win ? "YOU WON!" : "YOU LOST!");
            
            if(win && mode === 'online' && !isOnlineSync) {
                // Update Score
                db.ref('users/'+myPhone).child('score').transaction(s => (s||0)+10);
            }
            window.location.href = 'home.html';
        }
    }

    // --- DRAW ---
    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        
        // Lines
        ctx.lineWidth=3; ctx.strokeStyle='#5d4037';
        ctx.beginPath();
        nodes.forEach(n => n.n.forEach(nid => {
            if(n.id<nid) { let n2=nodes[nid]; ctx.moveTo(n.x,n.y); ctx.lineTo(n2.x,n2.y); }
        }));
        ctx.stroke();

        // Moves
        validMoves.forEach(m => {
            let n = nodes[m.to];
            ctx.beginPath(); ctx.arc(n.x,n.y,15,0,7); 
            ctx.fillStyle = m.kill?'rgba(255,0,0,0.5)':'rgba(0,255,0,0.5)'; ctx.fill();
        });

        // Pieces
        pieces.forEach(p => {
            if(!p.a) return;
            let n = nodes[p.id];
            ctx.beginPath(); ctx.arc(n.x,n.y,20,0,7);
            ctx.fillStyle = p.t===0 ? '#d32f2f' : '#1976d2'; ctx.fill();
            if(selected === p) { ctx.lineWidth=3; ctx.strokeStyle='#ffd700'; ctx.stroke(); }
            // Shine
            ctx.beginPath(); ctx.arc(n.x-5,n.y-5,5,0,7); ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.fill();
        });
    }

    function startGame() { updateStatus(); draw(); }
    init();

</script>
</body>
</html>
